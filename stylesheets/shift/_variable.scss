// =============================================================================
// =SHIFT - VARIABLE
// =============================================================================

@import "sassy-maps";
@import "SassyLists";
@import "aleksi/general/default-to";
@import "aleksi/general/css-rule";
@import "aleksi/lists/walk";
@import "aleksi/lists/remove-nth";
@import "aleksi/lists/replace-nth";
@import "aleksi/maps/map-insert";

@import "shift/config";
@import "shift/params/expression";
@import "shift/params/handle";
@import "shift/params/parse";
@import "shift/context";
@import "shift/query";

// =is-shift-variable( $var )
// -----------------------------------------------------------------------------
/// Checks whether the given variable defines values for different media
/// contexts. A shift variable is a map with keys that each describe a media
/// context (either a shift expression or a shift handle).
///
/// @param {any} $var - The variable to test
/// @return {bool} - Wheter $var is a shift variable or not
///
/// @access public
/// @since 0.3.0
///
/// @TODO: implement memoization for performance

@function is-shift-variable($var)
{
  // only maps can be shift variables
  @if type-of($var) != 'map' {
    @return false;
  }

  @each $key, $val in $var
  {
    // if any of the keys is neither a shift expression nor a shift handle
    @if $key != 'df' and not shift-validate-expression($key)
      and not shift-validate-handle($key)
    {
      // this is not a shift variable
      @return false;
    }
  }

  // all keys are either a shift expression or a shift handle
  @return true;
}

// =_shift-parse-keys( $var )
// -----------------------------------------------------------------------------
/// Parses each key in given shift variable, and returns a map pairing each key
/// with the parsed features it defines.
///
/// @param $var - the shift variable to parse
///
/// @throw Error - if $var is not a valid shift variable
/// @return {map} - the map of keys -> parsed features
///
/// @api private
/// @since 0.3.0
///
/// @todo: implement memoization for increased performance

@function _shift-parse-keys( $var )
{
  // this only works on valid shift variables
  @if not is-shift-variable($var) {
    @return throw-error('_shift-parse-keys(): $var must be a valid shift variable – was #{inspect($var)}.');
  }

  $params: ();
  @each $key, $val in $var {
    $params: map-set($params, $key, shift-parse($key));
  }

  @return $params;
}

// =_shift-key-lengths( $vars... )
// -----------------------------------------------------------------------------
/// Collects all media widths/heights found in given shift variable(s)' keys and
/// sorts them in ascending order. Regular variables use no media widths/heights
/// are therefor ignored.
///
/// @param {arglist} $vars.. - shift variable(s) to inspect
///
/// @return {map} map listing the 'width' and 'height' lengths
///
/// @api private
/// @since 0.3.0
///
/// @todo: return widths/heights per media

@function _shift-key-lengths( $vars... )
{
  $widths: ();
  $heights: ();

  @each $var in $vars
  {
    @if is-shift-variable($var)
    {
      $params: _shift-parse-keys($var);

      @each $key, $val in $var
      {
        $prm: map-get($params, $key);
        $min-w: map-get($prm, 'min-width');
        $max-w: map-get($prm, 'max-width');
        $min-h: map-get($prm, 'min-height');
        $max-h: map-get($prm, 'max-height');

        @if $min-w != null and not index($widths, $min-w) { $widths: append($widths, $min-w); }
        @if $max-w != null and not index($widths, $max-w) { $widths: append($widths, $max-w); }
        @if $min-h != null and not index($heights, $min-h) { $heights: append($heights, $min-h); }
        @if $max-h != null and not index($heights, $max-h) { $heights: append($heights, $max-h); }
      }
    }
  }

  @return (
    'widths': sl-sort($widths),
    'heights': sl-sort($heights)
  );
}

// =_shift-length-intervals( $lengths )
// -----------------------------------------------------------------------------
/// Builds shift params for each 'min-/max-' interval between given media
/// widths/heights, and returns them in an ordered list (first width-only
/// intervals, then height-only and finally mixed intervals).
/// 
/// @param {map} $lengths - map of widths/heights to build intervals for
/// @return {list} - The ordered list of params representing intervals
///
/// @api private
/// @since 0.3.0

@function _shift-length-intervals( $lengths )
{
  $widths: map-get($lengths, 'widths');
  $heights: map-get($lengths, 'heights');

  $total-w: length($widths);
  $total-h: length($heights);

  $w-params: ();
  $h-params: ();
  $params: ();

  @if $total-w > 0
  {
    // add 'max-' only params at the beginning
    $max-w-prm: ('max-width': nth($widths, 1));
    $w-params: append($w-params, $max-w-prm);
    $params: append($params, $max-w-prm);

    // add params for each 'min-' 'max-' interval
    @for $i from 1 to $total-w
    {
      $min-w: nth($widths, $i);
      $max-w: nth($widths, $i + 1);
      $prm: ('min-width': $min-w, 'max-width': $max-w);

      $w-params: append($w-params, $prm);
      $params: append($params, $prm);
    }

    // add 'min-' only params at the end
    $min-w-prm: ('min-width': nth($widths, $total-w));
    $w-params: append($w-params, $min-w-prm);
    $params: append($params, $min-w-prm);
  }

  @if $total-h > 0
  {
    // add 'max-' only params at the beginning
    $max-h-prm: ('max-height': nth($heights, 1));
    $h-params: append($h-params, $max-h-prm);
    $params: append($params, $max-h-prm);

    // add params for each 'min-' 'max-' interval
    @for $i from 1 to $total-h
    {
      $min-h: nth($heights, $i);
      $max-h: nth($heights, $i + 1);
      $prm: ('min-height': $min-h, 'max-height': $max-h);

      $h-params: append($h-params, $prm);
      $params: append($params, $prm);
    }

    // add 'min-' only params at the end
    $min-h-prm: ('min-height': nth($heights, $total-h));
    $h-params: append($h-params, $min-h-prm);
    $params: append($params, $min-h-prm);
  }

  // add mixed length params
  @if $total-w > 0 and $total-h > 0
  {
    @each $w-prm in $w-params
    {
      @each $h-prm in $h-params
      {
        $prm: map-merge($w-prm, $h-prm);
        $params: append($params, $prm);
      }
    }
  }

  @return $params;
}

// =shift-scope-variable( $var[, $context ])
// -----------------------------------------------------------------------------
/// Limits a shift-variable to the scope of given context. Keys that are out of
/// scope are removed, and keys overlapping context scope are limited to fit in.
/// **Note**: If a regular variable is given, it will be wrapped in a shift
/// variable using the context as single key.
///
/// @param $var - the shift variable to re-scope
/// @param $context [shift-context()] - the context features to use as scope
///
/// @throw Error - if $var is not a valid shift variable
/// @return {map} - the map of keys -> parsed features
///
/// @api public
/// @since 0.3.0
///
/// @todo: implement memoization for increased performance

@function shift-scope-variable( $var, $context: null )
{
  // default to current context
  $context: default-to($context, shift-context());

  // get context's scoping features
  $media: default-to(map-get($context, 'media'), $shift-media-type);
  $min-w: map-get($context, 'min-width');
  $max-w: map-get($context, 'max-width');
  $min-h: map-get($context, 'min-height');
  $max-h: map-get($context, 'max-height');

  // initialize scoped copy of variable
  $scoped: ();

  // if regular key was given
  @if not is-shift-variable($var) {
    // return a shift variable with scope as only key
    $scoped-key: shift-expression($context);
    @return map-set($scoped, $scoped-key, $var);
  }

  // get shift params for each key
  $params: _shift-parse-keys($var);

  @each $key, $val in $var
  {
    $prm: map-get($params, $key);
    $prm-media: default-to(map-get($prm, 'media-type'), $shift-media-type);
    $prm-min-w: map-get($prm, 'min-width');
    $prm-max-w: map-get($prm, 'max-width');
    $prm-min-h: map-get($prm, 'min-height');
    $prm-max-h: map-get($prm, 'max-height');

    // if key is out of context's scope
    @if $media != $prm-media
      or ($prm-min-w != null and $prm-min-w >= default-to($max-w, 999999))
      or ($prm-max-w != null and $prm-max-w < default-to($min-w, 0))
      or ($prm-min-h != null and $prm-min-h >= default-to($max-h, 999999))
      or ($prm-max-h != null and $prm-max-h < default-to($min-h, 0))
    {
      // don't add this value to scoped copy of variable
    }

    @else
    {
      // limit keys that overlap with context's scope
      @if default-to($prm-min-w, 0) < default-to($min-w, 0) {
        $prm: map-set($prm, 'min-width', $min-w);
      }

      @if default-to($prm-max-w, 999999) > default-to($max-w, 999999) {
        $prm: map-set($prm, 'max-width', $max-w);
      }

      @if default-to($prm-min-h, 0) < default-to($min-h, 0) {
        $prm: map-set($prm, 'min-height', $min-h);
      }

      @if default-to($prm-max-h, 999999) > default-to($max-h, 999999) {
        $prm: map-set($prm, 'max-height', $max-h);
      }

      // add value to scoped copy of variable
      $scoped-key: shift-expression($prm);
      $scoped: map-set($scoped, $scoped-key, $val);
    }
  }

  // return scoped copy of variable
  @return $scoped;
}

// =shift-value( $var[, $context ])
// -----------------------------------------------------------------------------
/// Returns the value(s) from a shift variable that correspond to given context.
/// **Note**: if a regular variable is given, that will be returned as is.
///
/// @param {map|any} $var - The shift variable to get value(s) from
/// @param {map} $context - The shift context for which to get value(s)
///
/// @todo: implement memoization for increased performance

@function shift-value( $var, $context: null )
{
  // return regular variables' value
  @if not is-shift-variable($var) {
    @return $var;
  }

  // default to current context
  $context: default-to($context, shift-context());

  // scope variable to context to remove irrelevant values
  $res: shift-scope-variable($var, $context);

  // return null if no value corresponded
  @if $res-ln == 0 {
    @return null;
  }

  // return a single value if only one key corresponded
  @else if $res-ln == 1 {
    @return map-get($res, nth(map-keys($res), 1));
  }

  // return all values that correspond
  @return $res;
}

// =shift-computed-value( $var[, $context ])
// -----------------------------------------------------------------------------
/// Returns the last value from a shift variable that corresponds to given
/// context. Assuming that the variable's values are output in the same order in
/// the final CSS, this is the computed value at given context.
///
/// @param {map} $var - the shift variable to retreive the value from
/// @param {map} $context - the shift context for which to retreive the value
///
/// @api public
/// @since 0.3.0
//
// WORKS ONLY IF CONTEXT DOES NOT OVERLAP KEY INTERVALS !!
// -> MAKE SURE THE KEY INTERVALS ARE MINIMAL BEFORE RUNNING THROUGH THIS..

@function shift-computed-value( $var, $context: null )
{
  // get context feature values
  $context: default-to($context, shift-context());

  $media: default-to(map-get($context, 'media-type'), $shift-media-type);
  $min-w: default-to(map-get($context, 'min-width'), 0);
  $max-w: default-to(map-get($context, 'max-width'), 999999);
  $min-h: default-to(map-get($context, 'min-height'), 0);
  $max-h: default-to(map-get($context, 'max-height'), 999999);

  // extract default value
  $df: map-get($var, 'df');
  $var: map-remove($var, 'df');

  // loop over other keys in reverse order, and get first value that fits
  $params: _shift-parse-keys($var);
  $keys: map-keys($var);
  $i: length($var);

  @while $i > 0
  {
    $key: nth($keys, $i);
    $prm: map-get($params, $key);

    $prm-media: default-to(map-get($prm, 'media-type'), $shift-media-type);
    $prm-min-w: default-to(map-get($prm, 'min-width'), 0);
    $prm-max-w: default-to(map-get($prm, 'max-width'), 999999);
    $prm-min-h: default-to(map-get($prm, 'min-height'), 0);
    $prm-max-h: default-to(map-get($prm, 'max-height'), 999999);

    // if context is in key's scope
    @if $media == $prm-media
      and $min-w >= $prm-min-w
      and $max-w <= $prm-max-w
      and $min-h >= $prm-min-h
      and $max-h <= $prm-max-h
    {
      // return its value
      @return map-get($var, $key);
    }

    $i: $i - 1;
  }

  // return default value (can be 'null')
  @return $df;
}

// =shift-transpose-variable( $var, $keys )
// -----------------------------------------------------------------------------
/// Transforms a shift variable, by using the given list of keys and the values
/// that correspond in the original variable.
///
/// @throw Error - if $var is not a valid shift variable
/// @return {map} - transformed variable, using given keys
///
/// @api public
/// @since 0.3.0
///
/// @todo: implement memoization for increased performance

@function shift-transpose-variable($var, $keys)
{
  @if not is-shift-variable($var) {
    @return throw-error('shift-transpose-variable(): $var must be a valid shift variable – was #{inspect($var)}.');
  }

  $res: ();

  @each $key in $keys
  {
    $val: shift-computed-value($var, shift-parse($key));
    $res: map-set($res, $key, $val);
  }

  @return $res;
}

// =shift-expand-variable( $var )
// -----------------------------------------------------------------------------
/// Expands a given shift variable, staggering keys to cover all possible width
/// and/or height intervals.
///
/// @param $var - the shift variable to re-scope
/// @param $context [shift-context()] - the context features to use as scope
///
/// @throw Error - if $var is not a valid shift variable
/// @return {map} - the map of keys -> parsed features
///
/// @api public
/// @since 0.3.0
///
/// @todo: implement memoization for increased performance

@function shift-expand-variable( $var )
{
  @if not is-shift-variable($var) {
    @return throw-error('shift-expand-variable(): $var must be a valid shift variable – was #{inspect($var)}.');
  }

  // get ordered length intervals from variable's keys
  $lengths: _shift-key-lengths($var);
  $intervals: _shift-length-intervals($lengths);

  $keys: walk($intervals, 'shift-expression');

  $keys: ();
  @each $prm in $intervals {
    $keys: append($keys, shift-expression($prm));
  }

  @return shift-transpose-variable($var, $keys);
}

// =shift-reduce-variable( $var )
// -----------------------------------------------------------------------------
/// Reduces a shift variable that was previously expanded using
/// 'shift-expand-variable', so it uses the least keys as possible.
///
/// @param {map} $var - the shift variable to reduce
/// @return {map} - a reduced copy of $var, with least keys being used
///
/// @api public
/// @since 0.3.0

@function shift-reduce-variable( $var )
{
  // only accept valid shift variables
  @if not is-shift-variable($var) {
    @return throw-error('shift-expand-variable(): $var must be a valid shift variable – was #{inspect($var)}.');
  }

  // reduce intervals from variable
  $res: _shift-reduce-intervals($var);

  // get default value (defaults to prevailing value)
  $df: '__none__';
  @if map-has-key($var, 'df') {
    $df: map-get($var, 'df');
  } @else {
    $df: _shift-prevailing-value($var);
  }

  // add default value at the beginning of reduced copy
  $res: map-insert($res, 1, ('df': $df));

  @return $res;
}

// =_shift-prevailing-value( $var )
// -----------------------------------------------------------------------------
/// Returns the value that occurs the most often in given shift variable. If all
/// values occur the same amount of times, the first value will be returned.
///
/// @param {map} $var - the shift variable to inspect
///
/// @return {any} the prevailing value in $var
/// @throw Error - if $var is not a shift variable
///
/// @api private
/// @since 0.3.0

@function _shift-prevailing-value($var)
{
  $most: '__none__';
  $vals: map-values($var);
  $counts: ();

  @each $val in $vals
  {
    // use index of first occurence of value as key
    $key: index($vals, $val);

    // update count for value
    $count: default-to(map-get($counts, $key), 0) + 1;
    $counts: map-set($counts, $key, $count);

    // update default value
    @if $most == '__none__'
      or $count > map-get($counts, index($vals, $most))
    {
      $most: $val;
    }
  }

  @return $most;
}

// =_shift-reduce-intervals( $var )
// -----------------------------------------------------------------------------
/// Reduces 'min-/max-' intervals in keys from given shift variable.
///
/// @return {map} - the shift variable with reduced intervals
/// @throw Error - if $var is not a shift variable
///
/// @api private
/// @since 0.3.0

@function _shift-reduce-intervals( $var )
{
  $values: map-values($var);
  $params: map-values(_shift-parse-keys($var));

  // compare each entry with next one
  $i: 1;
  $ln: length($var);

  @while $i < $ln
  {
    $next-i: $i + 1;

    $val: nth($values, $i);
    $next-val: nth($values, $next-i);

    $merge: false;

    @if $val == $next-val
    {
      // candidate for merging
      $prm: nth($params, $i);
      $min-w: map-get($prm, 'min-width');
      $max-w: map-get($prm, 'max-width');
      $min-h: map-get($prm, 'min-height');
      $max-h: map-get($prm, 'max-height');

      $next-prm: nth($params, $next-i);
      $next-min-w: map-get($next-prm, 'min-width');
      $next-max-w: map-get($next-prm, 'max-width');
      $next-min-h: map-get($next-prm, 'min-height');
      $next-max-h: map-get($next-prm, 'max-height');

      $merged: $prm;

      // if keys are compatible and width intervals follow-up
      @if default-to($min-h, 0) == default-to($next-min-h, 0)
        and default-to($max-h, 999999) == default-to($next-max-h, 999999)
        and default-to($max-w, 999999) >= default-to($next-min-w, 0)
      {
        // merge them by expanding max-w
        $merge: true;
        $merged: map-merge($merged, (
          'max-width': $next-max-w
        ));
      }

      // if keys are compatible and height intervals follow-up
      @if default-to($min-w, 0) == default-to($next-min-w, 0)
        and default-to($max-w, 999999) == default-to($next-max-w, 999999)
        and default-to($max-h, 999999) >= default-to($next-min-h, 0)
      {
        // merge them by expanding max-h
        $merge: true;
        $merged: map-merge($merged, (
          'max-height': $next-max-h
        ));
      }

      @if $merge == true
      {
        // remove next interval
        $values: remove-nth($values, $next-i);
        $params: remove-nth($params, $next-i);
        $ln: $ln - 1;

        // and replace current one with expanded one
        $params: replace-nth($params, $i, $merged);
      }
    }

    @else if $merge == false {
      // move on..
      $i: $i + 1;
    }
  }

  // build reduced copy of the variable based on new intervals
  $res: ();

  @for $i from 1 through $ln
  {
    $prm: nth($params, $i);
    $val: nth($values, $i);
    
    $res: map-set($res, shift-expression($prm), $val);
  }

  @return $res;
}

// =shift-align-variables( $vars )
// -----------------------------------------------------------------------------
/// Aligns multiple shift variables by transposing them to the same keys, which
/// represent the intervals between all media widths/heights found in the
/// original variable keys. This way, the variables can be compared directly.
///
/// @param $vars - the shift variables to align
/// @param $context [shift-context()] - the context features to use as scope
///
/// @return {list} - list of transposed $vars
///
/// @api public
/// @since 0.3.0

@function shift-align-variables( $vars, $context: null )
{
  // default to current context
  $context: default-to($context, shift-context());

  // limit variables to context scope
  // (also transforms regular variables into shift variables)
  $vars: walk($vars, 'shift-scope-variable', $context);

  // get complete list of media lengths and intervals from all orignal keys
  $lengths: _shift-key-lengths($vars...);
  $intervals: _shift-length-intervals($lengths);

  // initialize list of aligned variables
  $aligned: ();

  // transpose each variable to expanded interval keys
  $keys: walk($intervals, 'shift-expression');
  $aligned: walk($vars, 'shift-transpose-variable', $keys);

  @return $aligned;
}

// =shift-call( $fn[, $args... ])
// -----------------------------------------------------------------------------
/// Calls a given function with shift variable arguments. The function will be
/// called on each different value that is defined in the arguments.
///
/// @param $fn - the transforming function.
/// @param $args - the arguments to pass to $fn
///
/// @return {map} - a shift variable representing the different values returned by fn
///
/// @api public
/// @since 0.3.0

@function shift-call($fn, $args...)
{
  $res: ();

  // align all arguments and get list of shared keys
  $args: shift-align-variables($args);
  $keys: map-keys(nth($args, 1));

  @debug $args;

  // call transforming function with values for each key
  @each $key in $keys
  {
    $key-args: walk($args, 'map-get', $key);
    $key-val: call($fn, $key-args...);

    // and get value returned by transforming function
    $res: map-set($res, $key, $key-val);
  }

  @return $res;
}

// =shift-align-keys( $vars )
// -----------------------------------------------------------------------------

// @function shift-align-keys( $vars )
// {
//   $first: shift-scope-variable(nth($vars, 1));
//   $keys: map-keys($first);

//   @debug $first;

//   $num-vars: length($vars);

//   @for $i from 2 through $num-vars
//   {
//     $var: shift-scope-variable(nth($vars, $i));

//     @for $i from 1 through length($keys)
//     {
//       $key: nth($keys, $i);
//       $prm: shift-parse($key);
//       $key-val: shift-scope-variable($var, $prm);

//       @if length($key-val) > 1
//       {
//         // replace the current key, with those from returned value
//         $keys: sl-remove-nth($keys, $i);

//         $val-keys: map-keys($key-val);
//         $j: length($val-keys);

//         @while $j > 0
//         {
//           $k: nth($val-keys, $j);
//           $keys: sl-insert-nth($keys, $i, $k);
//           $j: $j - 1;
//         }
//       }
//     }
//   }

//   @return $keys;
// }

// // =shift-align-variables( $vars )
// // -----------------------------------------------------------------------------

// @function shift-align-variables( $vars )
// {
//   $widths: ();
//   $heights: ();

//   // collect unique values for length features
//   @each $var in $vars
//   {
//     $params: _shift-parse-keys($var);

//     @each $key, $prm in $params
//     {
//       $min-w: map-get($prm, 'min-width');
//       $max-w: map-get($prm, 'min-width');
//       $min-h: map-get($prm, 'min-height');
//       $max-h: map-get($prm, 'min-height');

//       @if $min-w != null and not index($widths, $min-w) {
//         $widths: append($widths, $min-w);
//       }

//       @if $max-w != null and not index($widths, $max-w) {
//         $widths: append($widths, $max-w);
//       }

//       @if $min-h != null and not index($widths, $min-h) {
//         $heights: append($widths, $min-h);
//       }

//       @if $max-h != null and not index($widths, $max-h) {
//         $heights: append($widths, $max-h);
//       }
//     }
//   }

//   // sort collected length values in ascending order
//   $widths: sl-sort($widths);
//   $heights: sl-sort($heights);

//   // create list of keys for all possible intervals...
//   $keys: ();

//   // add 'max-' length only at start
//   $keys: append($keys, shift-expression('max-width', nth($widths, 1)));

//   @for $w from 1 through $w-total
//   {
//     $min-w: if($w == 1, null, nth($widths, $w));
//     $max-w: if($w == $w-total, null, nth($widths, $w + 1));

//     @for $h from 1 through $h-total
//     {
//       $min-h: if($h == 1, null, nth($heights, $h));
//       $max-h: if($h == $h-total, null, nth($height, $h + 1));

//       $key: shift-expression((
//         'min-width': $min-w,
//         'max-width': $max-w,
//         'min-height': $min-h,
//         'max-height': $max-h
//       ));
//     }

//     @if $i == 1 {
//       $prm: ('max-width': $w);
//     }

//     @else if $i == $num-widths {
//       $prm: ('max-width': $w);
//     }

//     @else {
//       $prm: ('min-width': $w, 'max-width': $next-w);
//     }

//     $keys: append($keys, shift-expression($prm));
//   }

//   // add 'min-' length only at end

//   @return $keys;
// }

// =Mixins
// =============================================================================

// =shift-value( $prop, $var[, $important ])
// -----------------------------------------------------------------------------
/// Outputs styles for a given css property and corresponding values from a
/// shift variable, scoped into current context and wrapped in media-queries.
///
/// @param {string} $prop - The css property to output
/// @param {map} $var - The shift variable to use as value
/// @param {bool} $important - Whether to append the `!important` flag or not
///
/// @example scss
///   Example Code
///
/// @access public
/// @since 0.3.0

@mixin shift-value($prop, $var, $important: false)
{
  @if not is-shift-variable($var) {
    #{$prop}: css-value($var, $important);
  }

  // scope variable in current context
  $var: shift-scope-variable($var);

  @each $key, $val in $var
  {
    @at-root (without: media)
    {
      & {
        @include shift-query($key) {
          #{$prop}: css-value($val, $important);
        }
      }
    }
  }
}